#!/usr/bin/env python3
"""Generate docs/plans/CLAUDE.md index from plan files.

This script generates the plan index automatically from plan files,
eliminating the need for manual sync. Run on every commit via pre-commit hook.

Usage:
    python scripts/generate_plan_index.py              # Generate to stdout
    python scripts/generate_plan_index.py --write      # Write to file
    python scripts/generate_plan_index.py --check      # Check if index is current
"""

import argparse
import re
import sys
from pathlib import Path
from typing import Optional

PLANS_DIR = Path("docs/plans")
INDEX_FILE = PLANS_DIR / "CLAUDE.md"
TEMPLATE_FILE = PLANS_DIR / "CLAUDE.md.header"

# Status emoji mapping
STATUS_PATTERNS = {
    "âœ…": "Complete",
    "ðŸ“‹": "Planned",
    "ðŸš§": "In Progress",
    "âŒ": "Needs Plan",
    "â“": "Unknown",
}

# Text-based status patterns (fallback when no emoji)
TEXT_STATUS_PATTERNS = {
    "complete": "âœ…",
    "done": "âœ…",
    "superseded": "âœ…",
    "planned": "ðŸ“‹",
    "deferred": "ðŸ“‹",
    "in progress": "ðŸš§",
    "needs plan": "âŒ",
    "won't do": "âŒ",
}


def parse_plan_file(path: Path) -> Optional[dict]:
    """Parse a plan file and extract metadata."""
    content = path.read_text()

    # Extract plan number from filename
    match = re.match(r"(\d+)_(.+)\.md", path.name)
    if not match:
        return None

    plan_num = int(match.group(1))

    # Extract title from first heading
    title_match = re.search(r"^#\s+(?:Plan\s+#\d+:\s*)?(.+)$", content, re.MULTILINE)
    title = title_match.group(1).strip() if title_match else path.stem.replace("_", " ").title()

    # Extract status
    status_match = re.search(r"\*\*Status:\*\*\s*(.+)$", content, re.MULTILINE)
    status_line = status_match.group(1).strip() if status_match else ""

    # Determine status emoji
    status_emoji = "â“"
    status_text = ""

    # First try to find emoji in status line
    for emoji, name in STATUS_PATTERNS.items():
        if emoji in status_line:
            status_emoji = emoji
            # Extract any suffix after the emoji (e.g., "Complete", "Post-V1", "Deferred")
            parts = status_line.split(emoji, 1)
            if len(parts) > 1:
                status_text = parts[1].strip()
            break

    # Fallback: check for text-based status (no emoji)
    if status_emoji == "â“" and status_line:
        status_lower = status_line.lower()
        for text_pattern, emoji in TEXT_STATUS_PATTERNS.items():
            if text_pattern in status_lower:
                status_emoji = emoji
                # Normalize to canonical form (e.g., "complete" -> "Complete")
                status_text = STATUS_PATTERNS.get(emoji, status_line)
                break

    # Extract priority
    priority_match = re.search(r"\*\*Priority:\*\*\s*(.+)$", content, re.MULTILINE)
    priority = priority_match.group(1).strip() if priority_match else "Medium"

    # Extract blocks
    blocks_match = re.search(r"\*\*Blocks:\*\*\s*(.+)$", content, re.MULTILINE)
    blocks = blocks_match.group(1).strip() if blocks_match else "-"
    if blocks.lower() in ("none", "-", ""):
        blocks = "-"

    return {
        "number": plan_num,
        "title": title,
        "file": path.name,
        "priority": priority,
        "status_emoji": status_emoji,
        "status_text": status_text,
        "blocks": blocks,
    }


def get_header() -> str:
    """Get the static header content."""
    return '''<!-- AUTO-GENERATED FILE - DO NOT EDIT MANUALLY -->
<!-- Generated by: python scripts/generate_plan_index.py -->
<!-- To update: Edit individual plan files, then commit (pre-commit regenerates) -->

# Implementation Plans

Master index of all gaps and their implementation plans.

**Last generated:** Auto-updated on every commit

---

## Quick Start

1. **Find a gap** - Browse table below
2. **Read the plan** - `NN_name.md` for details
3. **Implement** - TDD: write tests first
4. **Complete** - `python scripts/complete_plan.py --plan N`

> **Note:** This index is auto-generated from plan files. Edit the plan files,
> not this index. The pre-commit hook regenerates this file automatically.

### Status Key

| Status | Meaning |
|--------|---------|
| ðŸ“‹ Planned | Ready to implement |
| ðŸš§ In Progress | Currently being worked on |
| âœ… Complete | Implemented and verified |
| âŒ Needs Plan | Needs design work |

---

## Gap Summary

| # | Gap | Priority | Status | Blocks |
|---|-----|----------|--------|--------|
'''


def get_footer() -> str:
    """Get the static footer content."""
    return '''
---

## TDD Workflow

```bash
# Check what tests to write
python scripts/check_plan_tests.py --plan N --tdd

# Run tests for a plan
python scripts/check_plan_tests.py --plan N

# Complete (runs E2E, records evidence)
python scripts/complete_plan.py --plan N
```

---

## Coordination

Active work is tracked by git branches. Check branches with:
```bash
git branch -r | grep plan-
```

Before starting new work:
```bash
make worktree BRANCH=plan-NN-description
```

---

## References

| Doc | Purpose |
|-----|---------|
| `docs/architecture/current/` | What IS implemented |
| `docs/architecture/target/` | What we WANT |
| `docs/architecture/gaps/` | 142-gap detailed analysis |
| `TEMPLATE.md` | New plan file template |
'''


def generate_index() -> str:
    """Generate the complete index content."""
    # Get all plan files
    plan_files = sorted(PLANS_DIR.glob("[0-9]*_*.md"))

    plans = []
    for pf in plan_files:
        meta = parse_plan_file(pf)
        if meta:
            plans.append(meta)

    # Sort by plan number
    plans.sort(key=lambda p: p["number"])

    # Generate table rows
    rows = []
    for p in plans:
        status = p["status_emoji"]
        if p["status_text"]:
            status = f"{p['status_emoji']} {p['status_text']}"

        row = f"| {p['number']} | [{p['title']}]({p['file']}) | {p['priority']} | {status} | {p['blocks']} |"
        rows.append(row)

    # Combine
    content = get_header()
    content += "\n".join(rows)
    content += get_footer()

    return content


def main():
    parser = argparse.ArgumentParser(description="Generate plan index from plan files")
    parser.add_argument("--write", action="store_true", help="Write to file instead of stdout")
    parser.add_argument("--check", action="store_true", help="Check if index is current (exit 1 if not)")
    args = parser.parse_args()

    generated = generate_index()

    if args.check:
        if not INDEX_FILE.exists():
            print("Index file does not exist")
            sys.exit(1)

        current = INDEX_FILE.read_text()
        if current.strip() != generated.strip():
            print("Index is out of date. Run: python scripts/generate_plan_index.py --write")
            sys.exit(1)

        print("Index is current")
        sys.exit(0)

    if args.write:
        INDEX_FILE.write_text(generated)
        print(f"Generated {INDEX_FILE}")
    else:
        print(generated)


if __name__ == "__main__":
    main()
