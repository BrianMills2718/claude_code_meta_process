#!/bin/bash
# Pre-commit hook for agent_ecology
# Catches issues before they reach CI

set -e

echo "Running pre-commit checks..."

# Get the repo root
REPO_ROOT=$(git rev-parse --show-toplevel)
cd "$REPO_ROOT"

# Get staged Python files
STAGED_PY=$(git diff --cached --name-only --diff-filter=ACM | grep '\.py$' || true)

# 1. Doc-coupling check (strict violations only)
echo "Checking doc-code coupling..."
if ! python scripts/check_doc_coupling.py --strict 2>/dev/null; then
    echo ""
    echo "ERROR: Doc-coupling violation detected!"
    echo "Run 'python scripts/check_doc_coupling.py --suggest' to see which docs to update."
    echo ""
    exit 1
fi

# 2. Mypy on changed src/ files
STAGED_SRC=$(echo "$STAGED_PY" | grep '^src/' || true)
if [ -n "$STAGED_SRC" ]; then
    echo "Running mypy on changed files..."
    MYPY_FILES=""
    for f in $STAGED_SRC; do
        case "$f" in
            src/config.py|src/world/*.py|src/agents/*.py)
                MYPY_FILES="$MYPY_FILES $f"
                ;;
        esac
    done

    if [ -n "$MYPY_FILES" ]; then
        if ! python -m mypy --strict --ignore-missing-imports $MYPY_FILES 2>/dev/null; then
            echo ""
            echo "ERROR: mypy type check failed!"
            echo ""
            exit 1
        fi
    fi
fi

# 3. Validate coupling config
echo "Validating coupling config..."
if ! python scripts/check_doc_coupling.py --validate-config 2>/dev/null; then
    echo ""
    echo "ERROR: Invalid doc-coupling config"
    echo ""
    exit 1
fi

# 4. Plan status consistency (only if plan files staged)
STAGED_PLANS=$(git diff --cached --name-only --diff-filter=ACM | grep '^docs/plans/' || true)
if [ -n "$STAGED_PLANS" ]; then
    echo "Checking plan status consistency..."
    if ! python scripts/sync_plan_status.py --check 2>/dev/null; then
        echo ""
        echo "ERROR: Plan status inconsistency detected!"
        echo "Run 'python scripts/sync_plan_status.py --check' to see details"
        echo "Run 'python scripts/sync_plan_status.py --sync' to sync index"
        echo ""
        exit 1
    fi
fi

# 5. Branch divergence check (prevents merge conflicts)
echo "Checking branch freshness..."
git fetch origin 2>/dev/null || true  # Silent fetch, don't fail if offline

BRANCH=$(git rev-parse --abbrev-ref HEAD 2>/dev/null) || true
REMOTE="origin/$BRANCH"

# Only check if remote branch exists
if git rev-parse --verify "$REMOTE" >/dev/null 2>&1; then
    LOCAL_ONLY=$(git rev-list "$REMOTE..HEAD" --count 2>/dev/null || echo "0")
    REMOTE_ONLY=$(git rev-list "HEAD..$REMOTE" --count 2>/dev/null || echo "0")

    if [ "$REMOTE_ONLY" -gt 0 ] && [ "$LOCAL_ONLY" -gt 0 ]; then
        echo ""
        echo "ERROR: Branch has diverged from remote!"
        echo "  Local commits not on remote: $LOCAL_ONLY"
        echo "  Remote commits not local: $REMOTE_ONLY"
        echo ""
        echo "Resolution:"
        echo "  git pull --rebase origin $BRANCH"
        echo ""
        echo "Then retry your commit."
        echo "Bypass with: git commit --no-verify (not recommended)"
        exit 1
    fi

    if [ "$REMOTE_ONLY" -gt 5 ]; then
        echo "WARNING: Branch is $REMOTE_ONLY commits behind remote"
        echo "Consider: git pull --rebase origin $BRANCH"
    fi
fi

echo "Pre-commit checks passed!"
